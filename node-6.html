
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Rémi Flamary" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Lecture notes for MAP555 :      Signal Processing" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>MAP555 : Signal Processing</title>
<link rel="stylesheet" type="text/css" href="map555.css" />



<!-- https://groups.google.com/forum/#!topic/
                                       mathjax-users/jUtewUcE2bY -->
<script type="text/x-mathjax-config">
MathJax.Hub.Register.StartupHook("TeX AMSmath Ready",function () {
      var seteqsectionDefault = {name: "", num: 0};
      var seteqsections = {}, seteqsection = seteqsectionDefault;
      var TEX = MathJax.InputJax.TeX, PARSE = TEX.Parse;
      var AMS = MathJax.Extension["TeX/AMSmath"];
      TEX.Definitions.Add({
      macros: {
            seteqsection: "mySection",
            seteqnumber: "mySetEqNumber"
      }
      });


      PARSE.Augment({
      mySection: function (name) {
            seteqsection.num = AMS.number;
            var n = this.GetArgument(name);
            if (n === "") {
                seteqsection = seteqsectionDefault;
            } else {
                if (!seteqsections["_"+n])
                     seteqsections["_"+n] = {name:n, num:0};
                seteqsection = seteqsections["_"+n];
            }
            AMS.number = seteqsection.num;
      },
      mySetEqNumber: function (name) {
            var n = this.GetArgument(name);
            if (!n || !n.match(/^ *[0-9]+ *$/))
                n = "";
            else
                n = parseInt(n)-1;
            <!-- $ syntax highlighting -->
            if (n === "" || n < 1)
                TEX.Error
                ("Argument to "+name+" should be a positive integer");
            AMS.number = n;
      }
      });
      MathJax.Hub.Config({
      TeX: {
            equationNumbers: {
                formatTag: function (n) {
                     <!-- if not numeric, don't include the chapter -->
                     if (!n.match(/^ *[0-9]+ *$/ ))
                     <!-- $ syntax highlighting -->
                            return "("+(n).replace(/^\./,"")+")" ;
                     else
                            return "("+(seteqsection.name+"."+n).replace(/^\./,"")+")" ;
                },
                formatID: function (n) {
                     n = (seteqsection.name+'.'+n).replace
                            (/[:"'<>&]/g,"").replace(/^\./,"");
                     return 'mjx-eqn-' + n;
                }
            }
      }
      });
});
</script>


<!-- http://docs.mathjax.org/en/latest/options/ThirdParty.html -->
<script type="text/x-mathjax-config">
  MathJax.Ajax.config.path["Contrib"] =
      "https://cdn.mathjax.org/mathjax/contrib";
</script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
      TeX: {
            extensions: ["autoload-all.js"] ,
            equationNumbers: {
                autoNumber: "AMS"
            }
      }
});
</script>


<!-- Alternative CDN provider: -->
<script type="text/javascript" async
src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS_HTML-full">
</script>


<!-- No longer supported after April 30, 2017: -->
<!--
<script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full">
</script>
-->
 <script type="text/javascript"
   src="navigation.js">
   </script>



</head>
<body>


<a id="poly-autopage-55"></a>
<nav class="topnavigation" ><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc" >
<div class="sidetoccontainer" >


<nav class="sidetoc" >


<div class="sidetoctitle" >

<p>
<span class="sidetocthetitle" >MAP555 : Signal Processing </span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents" >

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="node-1.html#autosec-6" class="tocchapter" >
<span class="sectionnumber" >1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="node-1.html#autosec-7" class="tocsection" >
<span class="sectionnumber" >1.1</span>&#x2003;Signal processing</a>
</p>


<p>
<a href="node-2.html#autosec-12" class="tocsection" >
<span class="sectionnumber" >1.2</span>&#x2003;Bibliographical notes</a>
</p>


<p>
<a href="node-3.html#autosec-19" class="tocsection" >
<span class="sectionnumber" >1.3</span>&#x2003;About this document</a>
</p>


<p>
<a href="node-4.html#autosec-21" class="tocchapter" >
<span class="sectionnumber" >2</span>&#x2003;Signals and convolution</a>
</p>


<p>
<a href="node-4.html#autosec-22" class="tocsection" >
<span class="sectionnumber" >2.1</span>&#x2003;Signals and properties</a>
</p>


<p>
<a href="node-5.html#autosec-46" class="tocsection" >
<span class="sectionnumber" >2.2</span>&#x2003;Convolution and filtering</a>
</p>


<p>
<a href="node-6.html#autosec-56" class="tocsection" >
<span class="sectionnumber" >2.3</span>&#x2003;Discrete time and digital signals</a>
</p>


<p>
<a href="node-7.html#autosec-79" class="tocsection" >
<span class="sectionnumber" >2.4</span>&#x2003;Fundamental signal processing problems</a>
</p>


<p>
<a href="node-8.html#autosec-84" class="tocchapter" >
<span class="sectionnumber" >3</span>&#x2003;Fourier analysis and analog filtering</a>
</p>


<p>
<a href="node-8.html#autosec-85" class="tocsection" >
<span class="sectionnumber" >3.1</span>&#x2003;Fourier transform</a>
</p>


<p>
<a href="node-9.html#autosec-87" class="tocsection" >
<span class="sectionnumber" >3.2</span>&#x2003;Frequency response and filtering</a>
</p>


<p>
<a href="node-10.html#autosec-89" class="tocsection" >
<span class="sectionnumber" >3.3</span>&#x2003;Applications of analog signal processing</a>
</p>


<p>
<a href="node-11.html#autosec-91" class="tocchapter" >
<span class="sectionnumber" >4</span>&#x2003;Digital signal processing</a>
</p>


<p>
<a href="node-11.html#autosec-92" class="tocsection" >
<span class="sectionnumber" >4.1</span>&#x2003;Sampling and Analog/Digital conversion</a>
</p>


<p>
<a href="node-12.html#autosec-94" class="tocsection" >
<span class="sectionnumber" >4.2</span>&#x2003;Digital filtering and transfer function</a>
</p>


<p>
<a href="node-13.html#autosec-96" class="tocsection" >
<span class="sectionnumber" >4.3</span>&#x2003;Finite signals and Fast Fourier Transform</a>
</p>


<p>
<a href="node-14.html#autosec-98" class="tocsection" >
<span class="sectionnumber" >4.4</span>&#x2003;Applications of DSP</a>
</p>


<p>
<a href="node-15.html#autosec-100" class="tocchapter" >
<span class="sectionnumber" >5</span>&#x2003;Random signals</a>
</p>


<p>
<a href="node-15.html#autosec-101" class="tocsection" >
<span class="sectionnumber" >5.1</span>&#x2003;Random Signals and Correlations</a>
</p>


<p>
<a href="node-16.html#autosec-103" class="tocsection" >
<span class="sectionnumber" >5.2</span>&#x2003;Frequency representation of random signals</a>
</p>


<p>
<a href="node-17.html#autosec-105" class="tocsection" >
<span class="sectionnumber" >5.3</span>&#x2003;AR modeling and linear prediction</a>
</p>


<p>
<a href="node-18.html#autosec-107" class="tocchapter" >
<span class="sectionnumber" >6</span>&#x2003;Signal representations</a>
</p>


<p>
<a href="node-18.html#autosec-108" class="tocsection" >
<span class="sectionnumber" >6.1</span>&#x2003;Short Time Fourier Transform</a>
</p>


<p>
<a href="node-19.html#autosec-110" class="tocsection" >
<span class="sectionnumber" >6.2</span>&#x2003;Common signal representations</a>
</p>


<p>
<a href="node-20.html#autosec-112" class="tocsection" >
<span class="sectionnumber" >6.3</span>&#x2003;Source separation and dictionary learning</a>
</p>


<p>
<a href="node-21.html#autosec-114" class="tocsection" >
<span class="sectionnumber" >6.4</span>&#x2003;Machine learning for signal processing</a>
</p>


<p>
<a href="node-22.html#autosec-116" class="tocchapter" >
Bibliography</a>
</p>


<p>
<a href="node-23.html#autosec-119" class="tocchapter" >
Index</a>
</p>


</div>

</nav>

</div>


<div class="bodycontainer" >


<section class="textbody" >

<h1></h1>

<!--MathJax customizations:-->


<div class="hidden" >

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand \footnote [2][]{\text {( Footnote #1 )}}\)

\(\newcommand \footnotemark [1][]{\text {( Footnote #1 )}}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\intertext }[1]{\\ \text {#1}\notag \\}\)

\(\newcommand {\dbR }{{\mathbb {R}}}\)

\(\newcommand {\R }{{\mathbb {R}}}\)

\(\newcommand {\dbC }{{\mathbb {C}}}\)

\(\newcommand {\v }{{\mathbf {v}}}\)

\(\newcommand {\x }{{\mathbf {x}}}\)

\(\newcommand {\h }{{\mathbf {h}}}\)

\(\newcommand {\y }{{\mathbf {y}}}\)

\(\newcommand {\C }{{\mathbf {C}}}\)

\(\newcommand {\H }{{\mathbf {H}}}\)

\(\newcommand {\p }{{\mathbf {p}}}\)

\(\newcommand {\ostar }{{{\mbox {$\;\odot \!\!\!\!\!\star ~$}}}}\)

\(\newcommand {\pause }{{ }}\)

</div>

<p>
<h4 id="autosec-56"><span class="sectionnumber" >2.3&#x2003;</span>Discrete time and digital signals</h4>
<a id="poly-autopage-56"></a>
<a id="sec:def_discrete_signal"></a>
<h5 id="autosec-57"><span class="sectionnumber" >2.3.1&#x2003;</span>Discrete time</h5>
<a id="poly-autopage-57"></a>
<p>
<span class="paragraph" id="autosec-58">Notations</span>
<a id="poly-autopage-58"></a>

</p>
<ul style="list-style-type:none">

<li>
<p>
• \(x(t)\) with \(t\in \R \) is the analog signal.
</p>


</li>
<li>
<p>
• \(x_T(t)\) with \(t\in \R \) is the sampled signal of period (T) but still continuous time:
</p>
<p>
\[ x_T(t)=\sum _{n=-\infty }^\infty x(nT)\delta (t-nT) \]
</p>
</li>
<li>
<p>
• \(x[n]\) with \(n\in \mathbb {Z}\) is the discrete signal sampled with period \(T\) such that:
</p>
<p>
\[ x[n]= x(nT) \]
</p>
</li>
<li>
<p>
• Obviously one can recover \(x_T(t)\) from \(x[n]\) with
</p>
<p>
\[ x_T(t)=\sum _{n=-\infty }^\infty x[n]\delta (t-nT) \]
</p>
</li>
<li>
<p>
• In order to simplify notations we will suppose \(T=1\) in the following.
</p>


</li>
<li>
<p>
• In this course we suppose that \(|x[n]|\) is bounded.
</p>
</li>
</ul>
<div class="center" >

<p>

<a href="imgs/sig_conv/dirac_delta_discrete.svg" target="_blank" ><img
    src="imgs/sig_conv/dirac_delta_discrete.svg"
    style="
    width:347pt;
    "
    class="inlineimage"
    alt="(image)"
></a>
</p>
</div>
<p>
<span class="paragraph" id="autosec-60">Discrete dirac</span>
<a id="poly-autopage-60"></a>
We note the discrete dirac \(\delta [n]\) defined as
</p>

<p>
<span class="hidden" > \( \seteqsection {2} \) </span>   <span class="hidden" > \( \seteqnumber {15} \) </span>
</p>
<!--

                                                                                                                                
                                                                                                                                    1   for n = 0
                                                                                                                       δ[n] =                       (2.15)--><a id="eq:discrete_dirac"></a><!--
                                                                                                                                    0   else


-->

<p>

\begin{equation} \delta [n]= \begin {cases} 1&amp; \text {for } n=0\\ 0 &amp; \text {else} \end {cases} \label {eq:discrete_dirac} \end{equation}

</p>
<p>
<span class="paragraph" id="autosec-61">Discrete signal</span>
<a id="poly-autopage-61"></a>
Any discrete signal \(x[n]\) can be decomposed as a sum of translated discrete diracs:
</p>

<p>
<span class="hidden" > \( \seteqsection {2} \) </span>      <span class="hidden" > \( \seteqnumber {16} \) </span>
</p>
<!--

                                                                                                                                ∞
                                                                                                                                X
                                                                                                                       x[n] =          x[k]δ[n − k]   (2.16)--><a id="eq:discreet_signal_dirac"></a><!--
                                                                                                                                k=−∞


-->

<p>

\begin{equation} x[n]=\sum _{k=-\infty }^\infty x[k]\delta [n-k] \label {eq:discreet_signal_dirac} \end{equation}

</p>

<p>
The discrete diracs are an orthogonal basis of \(L_2(\mathbb {Z})\) of scalar product and corresponding norm
</p>

<p>
\[&lt;x[n],h[n]&gt;=\sum _{k=-\infty }^\infty x[k]h^*[k],\qquad \|x[n]\|^2=&lt;x[n],x[n]&gt;=\sum _{k=-\infty }^\infty |x[k]|^2.\]
</p>
<p>
<span class="paragraph" id="autosec-62">Convolution between discrete signals</span>
<a id="poly-autopage-62"></a>
Let \(x[n]\) and \(h[n]\) two discrete signals. The convolution between them is expressed as:
</p>

<p>
<span class="hidden" > \( \seteqsection {2} \) </span>      <span class="hidden" > \( \seteqnumber {17} \) </span>
</p>
<!--

                                                                                                                                     ∞
                                                                                                                                     X
                                                                                                                     x[n] ? h[n] =          x[k]h[n − k]   (2.17)--><a id="eq:discrete_convolution"></a><!--
                                                                                                                                     k=−∞


-->

<p>

\begin{equation} x[n]\star h[n]= \sum _{k=-\infty }^\infty x[k]h[n-k] \label {eq:discrete_convolution} \end{equation}

</p>
<p>
<span class="paragraph" id="autosec-63">Digital filter properties</span>
<a id="poly-autopage-63"></a>
Let the discrete system/operator/filter \(L\) described by its impulse response \(h[n]\).
</p>
<ul style="list-style-type:none">

<li>
<p>
• <b>Causality</b> \(L\) is causal if \(h[n]=0,\ \forall n\leq 0\). \(L\) is causal if
</p>
<p>
<span class="hidden" > \( \seteqsection {2} \) </span>       <span class="hidden" > \( \seteqnumber {18} \) </span>
</p>
<!--
                                                                                                                                                       (
                                                                                                                                                       1   for n ≥ 0
                                                                                                            h[n] = h[n]Γ[n],      where       Γ[n] =                                                    (2.18)--><a id="eq:causal_discrete"></a><!--
                                                                                                                                                       0   else

-->
<p>


\begin{equation} h[n]=h[n]\Gamma [n],\qquad \text {where}\qquad \Gamma [n]= \begin {cases} 1&amp; \text {for } n\geq 0\\ 0 &amp; \text {else} \end {cases} \label {eq:causal_discrete} \end{equation}


</p>
</li>
<li>
<p>
• <b>Stability</b> A system is stable if the output of a bonded input is bounded. A necessary and sufficient condition is that
</p>
<p>
<span class="hidden" > \( \seteqsection {2} \) </span>       <span class="hidden" > \( \seteqnumber {19} \) </span>
</p>
<!--

                                                                                                                                 ∞
                                                                                                                                 X
                                                                                                                                        |h[n]| < ∞                                                        (2.19)--><a id="eq:stable_system"></a><!--
                                                                                                                                 n=−∞


-->
<p>


\begin{equation} \sum _{n=-\infty }^\infty |h[n]|&lt;\infty \label {eq:stable_system} \end{equation}


</p>
<p>


</p>
</li>
</ul>
<h5 id="autosec-64"><span class="sectionnumber" >2.3.2&#x2003;</span>Finite signals</h5>
<a id="poly-autopage-64"></a>


<a id="sec:finite"></a>
<div class="center" >

<p>

<a href="imgs/sig_conv/finite_discrete-crop.svg" target="_blank" ><img
    src="imgs/sig_conv/finite_discrete-crop.svg"
    style="
    width:347pt;
    "
    class="inlineimage"
    alt="(image)"
></a>
</p>
</div>
<p>
<span class="paragraph" id="autosec-66">Finite discrete signals</span>
<a id="poly-autopage-66"></a>

</p>
<ul style="list-style-type:none">

<li>
<p>
• Most of the theoretical results seen up to now correspond to signals \(x[n]\) where \(n\in \mathbb {Z}\).
</p>


</li>
<li>
<p>
• In practice recordings are only done for a finite amount of time resulting to only \(N\) samples.
</p>


</li>
<li>
<p>
• We defined \(\tilde x[n]\) a finite signal of \(N\) samples with \(n\in \{0,\dots ,N-1\}\).
</p>


</li>
<li>
<p>
• We use in the following the periodization of \(\bar x[n]\)
</p>
<p>
\[ x[n] = \tilde x[n\mod N] \]
</p>
<p>
where \(\mod \) is the modulo operator.
</p>
</li>
</ul>
<p>
<span class="paragraph" id="autosec-67">Discrete convolution of finite signals</span>
<a id="poly-autopage-67"></a>
The convolution between \(\tilde x[n]\) and \(\tilde h[n]\) both finite signals of \(n\) samples can be expressed as:
</p>

<p>
<span class="hidden" > \( \seteqsection {2} \) </span>       <span class="hidden" > \( \seteqnumber {20} \) </span>
</p>
<!--

                                                                                                                                                  +∞
                                                                                                                                                  X
                                                                                                                        ỹ[n] = x̃[n] ? h̃[n] =          x̃[p]h̃[n − p]    (2.20)--><a id="eq:conv_finite"></a><!--
                                                                                                                                                  p=−∞

-->

<p>

\begin{equation} \tilde y[n]=\tilde x[n]\star \tilde h[n] = \sum _{p=-\infty }^{+\infty } \tilde x[p] \tilde h[n-p] \label {eq:conv_finite}\vspace {-3mm} \end{equation}

</p>

<ul style="list-style-type:none">

<li>
<p>
• It requires values for the signals outside of the sampling widow.
</p>


</li>
<li>
<p>
• One common approach consists in having \(\tilde x[n]\) and \(\tilde h[n]\) equal to \(0\) outside the sampling interval. Other choices can be done (see next slides)
</p>
</li>
</ul>
<p>
<span class="paragraph" id="autosec-68">Circular convolution</span>
<a id="poly-autopage-68"></a>
When using the periodic version of the signals the circular convolution can be computed on a unique period of size \(N\):
</p>

<p>
\[ x \ostar h [n] = \sum _{p=0}^{N-1} x[p] h[n-p] . \]
</p>

<p>
The circular convolution is rarely appropriate in real life images due to border effects.

<p>

</p>
<p>
<span class="paragraph" id="autosec-69">Vector representation and convolution matrix</span>
<a id="poly-autopage-69"></a>

</p>
<ul style="list-style-type:none">

<li>
<p>
• Finite signal \(x\) of \(N\) samples can be represented as a vector \(\x \in \mathbb {C}^N\).
</p>


</li>
<li>
<p>
• The convolution operator is linear and can be expressed as:
</p>
<p>
\[ \y =\x \star \h = \C _\h \x \]
</p>
<p>
Where \(\C _\h \in \mathcal {M}_\mathbb {C}(N,N)\) is a convolution matrix parametrized by vector \(\h \).
</p>
</li>
</ul>
<p>
<span class="paragraph" id="autosec-70">Discrete convolution</span>
<a id="poly-autopage-70"></a>
The convolution operator when the values outside the support are \(0\) can be expressed as
</p>

<p>
\[ \hspace {-3mm}\C _\h \hspace {-.5mm} =\hspace {-.5mm}\begin {bmatrix} h[0] &amp; 0 &amp; \cdots &amp; 0\\ h[1] &amp; h[0] &amp; \cdots &amp; 0\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ h[N\hspace {-.5mm}-\hspace {-.5mm}1] &amp;
h[N\hspace {-.5mm}-\hspace {-.5mm}2 ] &amp; \dots &amp; h[0]\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp;\cdots &amp; h[N\hspace {-.5mm}-\hspace {-.5mm}1] \end {bmatrix} \]
</p>

<p>
where \(\C _\h \in \mathcal {M}_\mathbb {C}(2*N-1,N)\) is a Toeplitz matrix.

<p>

</p>
<p>
<span class="paragraph" id="autosec-71">Circular convolution</span>
<a id="poly-autopage-71"></a>
The circular convolution operator can be expressed as
</p>

<p>
\[ \C _\h =\begin {bmatrix} h[0] &amp; h[N-1] &amp; \cdots &amp; h[1]\\ h[1] &amp; h[0] &amp; \cdots &amp; h[2]\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ h[N-1] &amp; h[N-2 ] &amp; \dots &amp; h[0]\\ \end {bmatrix} \]
</p>

<p>
where \(\C _\h \in \mathcal {M}_\mathbb {C}(N,N)\) is a circulant Toeplitz matrix.

<p>

</p>
<div class="center" >

<p>

<a href="imgs/sig_conv/circ_conv_border.svg" target="_blank" ><img
    src="imgs/sig_conv/circ_conv_border.svg"
    style="
    width:390pt;
    "
    class="inlineimage"
    alt="(image)"
></a>
</p>
</div>

<ul style="list-style-type:none">

<li>
<p>
• Convolution between diracs \(\tilde x[n]\) and a shape \(h[n]\) will repeat the shape at the diracs position.
</p>


</li>
<li>
<p>
• A dirac at the end of the signal will cut the shape for discrete convolution where the outside of the sampling is \(0\).
</p>


</li>
<li>
<p>
• With circular convolution the shape is repeated t the beginning of the signal.
</p>


</li>
<li>
<p>
• One can remove border effects by creating virtual periodic signal with zeros (zero padding, see fast convolution).
</p>
</li>
</ul>
<div class="center" >

<p>

<a href="imgs/sig_conv/conv_scipy_signal.svg" target="_blank" ><img
    src="imgs/sig_conv/conv_scipy_signal.svg"
    style="
    width:434pt;
    "
    class="inlineimage"
    alt="(image)"
></a>
</p>
</div>
<p>
<span class="paragraph" id="autosec-74">The Scipy <kbd>scipy.signal.convolve</kbd> function:</span>
<a id="poly-autopage-74"></a>

</p>
<ul style="list-style-type:none">

<li>
<p>
• Convolution between two signals of support respectively \(N\) and \(M\) samples supposing that their values are \(0\) outside of the support.
</p>


</li>
<li>
<p>
• The third parameter is <kbd>mode</kbd> that change the size of the output :
</p>
<ul style="list-style-type:none">


<li>
<p>
– <kbd>mode=’full’</kbd> returns a signal of support \(N+M-1\) (default).
</p>


</li>
<li>
<p>
– <kbd>mode=’valid’</kbd> returns a signal of support \(|N-M|+1\) with only the samples that do not rely on zeros padding of the larger signal.
</p>


</li>
<li>
<p>
– <kbd>mode=’same’</kbd> returns a signal of the same size as the first input.
</p>
</li>
</ul>
</li>
<li>
<p>
• Parameter <kbd>method</kbd> allows to choose between <kbd>’direct’</kbd> computation and <kbd>’fft’</kbd> and selects the most efficient by default.
</p>
</li>
</ul>
<div class="center" >

<p>

<a href="imgs/sig_conv/conv_scipy_ndimage.svg" target="_blank" ><img
    src="imgs/sig_conv/conv_scipy_ndimage.svg"
    style="
    width:434pt;
    "
    class="inlineimage"
    alt="(image)"
></a>
</p>

</div>
<p>
<span class="paragraph" id="autosec-76">The Scipy <kbd>scipy.ndimage.convolve</kbd> function:</span>
<a id="poly-autopage-76"></a>

</p>
<ul style="list-style-type:none">

<li>
<p>
• Always return the same size as the first parameter by default.
</p>


</li>
<li>
<p>
• The <kbd>mode</kbd> parameter allows selecting the borders of a signal \(x=(abcd)\):
</p>
<ul style="list-style-type:none">


<li>
<p>
– <kbd>mode=’reflect’</kbd> : \((d c b a | a b c d | d c b a)\) (default)
</p>


</li>
<li>
<p>
– <kbd>mode=’constant’</kbd> : \((k k k k | a b c d | k k k k)\)
</p>


</li>
<li>
<p>
– <kbd>mode=’nearest’</kbd> : \((a a a a | a b c d | d d d d)\)
</p>


</li>
<li>
<p>
– <kbd>mode=’mirror’</kbd> : \((d c b | a b c d | c b a)\)
</p>


</li>
<li>
<p>
– <kbd>mode=’wrap’</kbd> : \((a b c d | a b c d | a b c d)\) (circular convolution)
</p>
</li>
</ul>
</li>
<li>
<p>
• Parameter <kbd>origin</kbd> allows to select the origin of the filter \(h\).
</p>
</li>
</ul>
<h5 id="autosec-77"><span class="sectionnumber" >2.3.3&#x2003;</span>Quantization and storage</h5>
<a id="poly-autopage-77"></a>


<a id="sec:"></a>

</section>

</div>

</div>

<footer>

<p>
<p><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /> Rémi Flamary, 2021</p>
</p>

</footer>


<nav class="botnavigation" ><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
